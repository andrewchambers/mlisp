use std

type obj = union
	`Sym byte[:]
	`Int int64
	`List list
	`Func func
	`Env env#
;;

type reader = struct
	input : byte[:]
	idx : int
;;

type list = struct
	head : std.option(obj#)
	tail : std.option(obj#)
;;

type func = struct
	body : obj#
;;

type env = struct
	parent : std.option(obj#)
	child : std.option(obj#)
	map : std.htab(obj#, obj#)#
;;

type ulisp = struct
	global : obj#
	gcptrs : obj#[:]
;;

const envhash = {pobj
	match pobj
	| &(`Sym name):	-> std.strhash(name)
	| _:	std.fatal("internal error\n")
	;;
}

const enveq = {a, b
	match (a, b)
	| (&(`Sym n1), &(`Sym n2)):	-> std.streq(n1, n2)
	| _:	std.fatal("internal error\n")
	;;
}

const mkenv = {ctx, parent
	var obj, env
	
	obj = std.alloc()
	env = std.alloc()
	env.parent = parent
	env.child = `std.None
	env.map = std.mkht(envhash, enveq)
	obj# = `Env env
	addgcobj(ctx, obj)
	-> obj
}

const mksym = {ctx, name
	var sym
	
	sym = std.mk(`Sym std.sldup(name))
	addgcobj(ctx, sym)
	-> sym	
}

const mknum = {ctx, v
	var n
	
	n = std.mk(`Int v)
	addgcobj(ctx, n)
	-> n	
}

const addgcobj = {ctx, pobj
	ctx.gcptrs = std.slpush(ctx.gcptrs, pobj)
}

const gchash = {pobj
	-> pobj castto(uint32)
}

const gceq = {a, b
	-> a == b
}

const gcfree = {pobj
	match pobj
	| &(`Sym name):
		std.put("freeing {}\n", name)
		std.slfree(name)
	| &(`Env env):
		std.htfree(env.map)
		std.free(env)
	| &(`Int _):
	| &(`List _):
	| &(`Func _):
	;;
	std.free(pobj)
}

const gcwalk = {gctab, pobj
	if std.get(std.htget(gctab, pobj))
		-> void
	;;
	std.htput(gctab, pobj, true)
	match pobj
	| &(`Sym _):
	| &(`Int _):
	| &(`Env e):
		var syms = std.htkeys(e.map)
		for sym in syms
			gcwalk(gctab, sym)
			gcwalk(gctab, std.get(std.htget(e.map, sym)))
		;;
		std.slfree(syms)
	| &(`List l):
		match l.head
		| `std.Some head:
			gcwalk(gctab, head)
		| _:
		;;
		match l.head
		| `std.Some tail:
			gcwalk(gctab, tail)
		| _:
		;;
	| &(`Func f):
		gcwalk(gctab, f.body)
	;;
}

const gc = {ctx
	var survivors, todie
	var marktab, marked
	
	survivors = [][:]
	todie = [][:]
	
	marktab = std.mkht(gchash, gceq)
	for obj in ctx.gcptrs
		std.htput(marktab, obj, false) 
	;;
	/* mark */
	gcwalk(marktab, ctx.global)
	/* sweep */
	for obj in ctx.gcptrs
		marked = std.get(std.htget(marktab, obj))
		if marked
			survivors = std.slpush(survivors, obj)
		else
			todie = std.slpush(todie, obj)
		;;
	;;
	for obj in todie
		gcfree(obj)
	;;
	std.htfree(marktab)
	std.slfree(ctx.gcptrs)
	std.slfree(todie)
	ctx.gcptrs = survivors
}

const envdefine = {env, sym, pobj
	match env
	| &(`Env e):	std.htput(e.map, sym, pobj)
	| _:	std.fatal("internal error\n")
	;;
	-> pobj
}

const envlookup = {env, sym
	match env
	| &(`Env e):
		match std.htget(e.map, sym)
		| `std.Some v:	-> `std.Some v
		| `std.None:
		;;
		match e.parent
		| `std.Some p:	-> envlookup(p, sym)
		| `std.None:	-> `std.None
		;;
	| _:
		std.fatal("internal error\n")
	;;
}

const eval = {ctx, env, val
	match val
	| &(`Sym name):
		match envlookup(env, val)
		| `std.Some r: -> r
		| `std.None:	std.fatal("cannot find {} in the current scope\n", name)
		;;
	| &(`Int _): -> val
	| &(`List [
		.head = `std.Some &(`Sym "if"),
		.tail = `std.Some &(`List [
			.head = `std.Some cond, 
			.tail = `std.Some &(`List [
				.head = `std.Some iftrue, 
				.tail = `std.Some &(`List [
					.head = `std.Some iffalse, 
					.tail = `std.None])])])]):
		match eval(ctx, env, cond)
		| &(`Sym "#t"):
			-> eval(ctx, env, iftrue)
		| _:
			-> eval(ctx, env, iffalse)
		;;
	| &(`List [
		.head = `std.Some &(`Sym "def"),
		.tail = `std.Some &(`List [
			.head = `std.Some sym, 
			.tail = `std.Some &(`List [
				.head = `std.Some rhs, 
				.tail = `std.None])])]):
		-> envdefine(env, sym, eval(ctx, env, rhs))
	| &(`List l): -> evalcall(ctx, env, l) 
	| _: std.fatal("cannot eval value\n")
	;;
}

const evalcall = {ctx, env, l
	match l.head
	
	| `std.Some &(`Sym "def"):
		-> mksym(ctx, "#t")
	| _: std.fatal("cannot eval value\n")
	;;
}

const newulisp = {
	var ctx
	
	ctx = std.alloc()
	ctx.gcptrs = [][:]
	ctx.global = mkenv(ctx, `std.None)
	-> ctx
}

const mkrdr = {txt
	-> std.mk([.input = txt, .idx = 0])
}

const peekchar = {rdr
	if rdr.idx == rdr.input.len
		-> `std.None
	;;
	-> `std.Some rdr.input[rdr.idx]
}

const getchar = {rdr
	var c
	
	c = peekchar(rdr)
	rdr.idx++
	-> c
}

const isdigit = {c
	if c < '0' castto(byte)
		-> false
	;;
	if c > '9' castto(byte)
		-> false
	;;
	-> true
}

const readnum = {ctx, rdr
	var n
	
	n = 0
	while true
		match peekchar(rdr)
		| `std.Some c:
			if !isdigit(c)
				break
			;;
			getchar(rdr)
			n *= 10
			n += (c - ('0' castto(byte))) castto(int64)
		| `std.None:
			break
		;;
	;;
	-> mknum(ctx, n)
}

const readlist = {ctx, rdr
	var r
	
	while true
		match peekchar(rdr)
		/*
		| `std.Some ')':
			getchar(rdr)
			break
		*/
		| `std.None:
			std.fatal("unclosed list\n")
		| _:
			r = read(ctx, rdr)
		;;
	;;
}

const read = {ctx, rdr
	match peekchar(rdr)
	/*
	| `std.Some '(':
		-> readlist(ctx, rdr)
		*/
	| `std.Some c:
		if isdigit(c)
			-> `std.Some readnum(ctx, rdr)
		;;
	| `std.None: -> `std.None
	;;
	-> `std.None
}

const main = {
	var ctx : ulisp#
	var rdr : reader#
	
	ctx = newulisp()
	rdr = mkrdr("123")
	match read(ctx, rdr)
	| `std.Some &(`Int v):
		std.put("readint {}\n", v)
	| `std.Some pobj:
		eval(ctx, ctx.global, pobj)
	| `std.None:
		std.fatal("read failed...\n")
	;;
	gc(ctx)
}
