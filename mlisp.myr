use std

type obj = union
	`Sym byte[:]
	`Int int64
	`List std.option((obj#, obj#))
	`Func func
	`Builtin (ctx : lisp#, e : obj#, args : obj# -> obj#)
	`Env env#
;;

type reader = struct
	input : byte[:]
	idx : int
;;

type func = struct
	body : obj#
;;

type env = struct
	parent : std.option(obj#)
	child : std.option(obj#)
	map : std.htab(obj#, obj#)#
;;

type lisp = struct
	global : obj#
	gcptrs : obj#[:]
;;

const printobj = {pobj : obj#
	match pobj
	| &(`Sym name):
		std.put("sym {}\n", name)
	| &(`Env env):
		std.put("env\n")
	| &(`List _):
		std.put("list\n")
	| &(`Int _):
		std.put("int\n")
	| &(`Func _):
		std.put("func\n")
	| &(`Builtin _):
		std.put("builtin\n")
	;;
}

const envhash = {pobj
	match pobj
	| &(`Sym name):	-> std.strhash(name)
	| _:	std.fatal("internal error\n")
	;;
}

const enveq = {a, b
	match (a, b)
	| (&(`Sym n1), &(`Sym n2)):	-> std.streq(n1, n2)
	| _:	std.fatal("internal error\n")
	;;
}

const mklisp = {
	var ctx
	
	ctx = std.alloc()
	ctx.gcptrs = [][:]
	ctx.global = mkenv(ctx, `std.None)
	-> ctx
}

const mkenv = {ctx, parent
	var obj, env
	
	obj = std.alloc()
	env = std.alloc()
	env.parent = parent
	env.child = `std.None
	env.map = std.mkht(envhash, enveq)
	obj# = `Env env
	addgcobj(ctx, obj)
	-> obj
}

const mkemptylist = {ctx
	var l
	
	l = std.mk(`List `std.None)
	addgcobj(ctx, l)
	-> l
}

const slicetolist = {ctx, sl
	var l
	
	l = mkemptylist(ctx)
	for var i = sl.len - 1; i >= 0; i--
		l = mklist(ctx, sl[i], l)
	;;
	-> l
}

const mklist = {ctx, val, rest
	var l
	
	l = std.mk(`List `std.Some (val, rest))
	addgcobj(ctx, l)
	-> l
}

const mksym = {ctx, name
	var sym
	
	sym = std.mk(`Sym std.sldup(name))
	addgcobj(ctx, sym)
	-> sym	
}

const mknum = {ctx, v
	var n
	
	n = std.mk(`Int v)
	addgcobj(ctx, n)
	-> n	
}

const addgcobj = {ctx, pobj
	ctx.gcptrs = std.slpush(ctx.gcptrs, pobj)
}

const gchash = {pobj
	-> pobj castto(uint32)
}

const gceq = {a, b
	-> a == b
}

const gcfree = {pobj
	match pobj
	| &(`Sym name):
		std.slfree(name)
	| &(`Env env):
		std.htfree(env.map)
		std.free(env)
	| &(`List _):
	| &(`Int _):
	| &(`Func _):
	| &(`Builtin _):
	;;
	std.free(pobj)
}

const gcwalk = {gctab, pobj
	if std.get(std.htget(gctab, pobj))
		-> void
	;;
	std.htput(gctab, pobj, true)
	match pobj
	| &(`Sym _):
	| &(`Int _):
	| &(`Env e):
		var syms = std.htkeys(e.map)
		for sym in syms
			gcwalk(gctab, sym)
			gcwalk(gctab, std.get(std.htget(e.map, sym)))
		;;
		std.slfree(syms)
	| &(`List `std.Some (val, rest)):
		gcwalk(gctab, val)
		gcwalk(gctab, rest)
	| &(`List `std.None):
	| &(`Func f):
		gcwalk(gctab, f.body)
	| &(`Builtin _):
	;;
}

const gc = {ctx
	var survivors, todie
	var marktab, marked
	
	survivors = [][:]
	todie = [][:]
	
	marktab = std.mkht(gchash, gceq)
	for obj in ctx.gcptrs
		std.htput(marktab, obj, false) 
	;;
	/* mark */
	gcwalk(marktab, ctx.global)
	/* sweep */
	for obj in ctx.gcptrs
		marked = std.get(std.htget(marktab, obj))
		if marked
			survivors = std.slpush(survivors, obj)
		else
			todie = std.slpush(todie, obj)
		;;
	;;
	for obj in todie
		gcfree(obj)
	;;
	std.htfree(marktab)
	std.slfree(ctx.gcptrs)
	std.slfree(todie)
	ctx.gcptrs = survivors
}

const envdefine = {env, sym, pobj
	std.put("defining val\n")
	printobj(sym)
	printobj(pobj)
	match env
	| &(`Env e):	std.htput(e.map, sym, pobj)
	| _:	std.fatal("internal error\n")
	;;
	-> pobj
}

const envlookup = {env, sym
	match env
	| &(`Env e):
		match std.htget(e.map, sym)
		| `std.Some v:	-> `std.Some v
		| `std.None:
		;;
		match e.parent
		| `std.Some p:	-> envlookup(p, sym)
		| `std.None:	-> `std.None
		;;
	| _:
		std.fatal("internal error\n")
	;;
}

const eval = {ctx, env, val
	match val
	| &(`Sym name):
		match envlookup(env, val)
		| `std.Some r: -> r
		| `std.None:	std.fatal("cannot find {} in the current scope\n", name)
		;;
	| &(`Int _): -> val
	| &(`List _): -> evalcall(ctx, env, val)
	| _: std.fatal("cannot eval value\n")
	;;
}

const apply = {ctx, env, f, params
	-> mksym(ctx, "fuck")
}

const evalcall = {ctx, env, list
	var f
	
	match list
	| &(`List `std.None):
		std.fatal("cannot eval an empty list")
	| &(`List `std.Some (val, rest)):
		f = eval(ctx, env, val)
		match f
		| &(`Builtin bif):
			-> bif(ctx, env, rest)
		| &(`Func _):
			-> apply(ctx, env, f, evallist(ctx, env, rest))
		| _:
			printobj(f)
			std.fatal("can only call builtins or functions\n")
		;;
	| _: std.fatal("internal error\n")
	;;
}

const evallist = {ctx, env, list
	var sl, result
	
	sl = std.slalloc(0)
	while true
		match list
		| &(`List `std.Some (v, rest)):
			sl = std.slpush(sl, eval(ctx, env, v))
			list = rest
		| &(`List `std.None):
			break
		| _:
			std.fatal("cannot eval malformed list\n")
		;;
	;;
	result = slicetolist(ctx, sl)
	std.slfree(sl)
	-> result
}

const mkreader = {txt
	-> std.mk([.input = txt, .idx = 0])
}

const peekchar = {rdr
	if rdr.idx == rdr.input.len
		-> `std.None
	;;
	-> `std.Some rdr.input[rdr.idx]
}

const getchar = {rdr
	var c
	
	c = peekchar(rdr)
	if rdr.idx != rdr.input.len
		rdr.idx++
	;;
	-> c
}

const isdigit = {c
	if c < '0' castto(byte)
		-> false
	;;
	if c > '9' castto(byte)
		-> false
	;;
	-> true
}

const isws = {b
	var c
	
	c = b castto(char)
	if c == ' ' || c == '\n' || c == '\t'
		-> true
	;;
	-> false
}

const readnum = {ctx, rdr
	var n
	
	n = 0
	while true
		match peekchar(rdr)
		| `std.Some c:
			if !isdigit(c)
				break
			;;
			getchar(rdr)
			n *= 10
			n += (c - ('0' castto(byte))) castto(int64)
		| `std.None:
			break
		;;
	;;
	-> mknum(ctx, n)
}

const readsym = {ctx, rdr
	var name, sym
	
	name = [][:]
	while true
		match peekchar(rdr)
		| `std.Some c:
			if c == ('(' castto(byte)) || c == (')' castto(byte)) || isws(c)
				break
			;;
			name = std.slpush(name, c)
			getchar(rdr)	
		| `std.None:
			break
		;;
	;;
	sym = mksym(ctx, name)
	std.slfree(name)
	printobj(sym)
	-> sym
}

const readlist = {ctx, rdr
	var l, sl
	
	sl = std.slalloc(0)
	getchar(rdr)
	while true
		skipws(rdr)
		match peekchar(rdr)
		| `std.Some 41:
			getchar(rdr)
			break
		| `std.Some c:
			match read(ctx, rdr)
			| `std.Some v:
				sl = std.slpush(sl, v)
			| _:
				std.fatal("failed to read list element\n")
			;;
		| `std.None:
			std.fatal("unclosed list\n")
		;;
	;;
	l = slicetolist(ctx, sl)
	std.slfree(sl)
	-> l
}

const skipws = {rdr
	while true
		match peekchar(rdr)
		| `std.Some c:
			if !isws(c)
				break
			;;
		| `std.None:
			break
		;;
		getchar(rdr)
	;;
}

const read = {ctx : lisp#, rdr : reader# -> std.option(obj#) 
	skipws(rdr)
	match peekchar(rdr)
	| `std.Some 40:
		-> `std.Some readlist(ctx, rdr)
	| `std.Some c:
		if isdigit(c)
			-> `std.Some readnum(ctx, rdr)
		;;
		-> `std.Some readsym(ctx, rdr)
	| `std.None:
		-> `std.None
	;;
}

const listlen = {l
	var len = 0
	while true
		match l
		| &(`List `std.Some (_, rest)):
			len++
			l = rest
		| &(`List `std.None): break
		| _: std.fatal("bad list while getting len\n")
		;;
	;;
	-> len
}

const builtin_if = {ctx, env, params -> obj#
	match params
	| &(`List `std.Some (cond, \
		&(`List `std.Some (iftrue, \
		&(`List `std.Some (iffalse, &(`List `std.None))))))):
		match eval(ctx, env, cond)
		| &(`Sym "#t"):
			-> eval(ctx, env, iftrue)
		| _:
			-> eval(ctx, env, iffalse)
		;;
	| _:
		std.fatal("malformed if\n")
	;;
}

const builtin_eq = {ctx, env, params -> obj#
	var l, r, eq
	
	params = evallist(ctx, env, params)
	match params
	| &(`List `std.Some (L , \
		&(`List `std.Some (R, \ 
		&(`List `std.None))))):
		l = L
		r = R
	| _:
		std.fatal("= requires two parameters")
	;;
	
	match (l, r)
	| (&(`Int v1), &(`Int v2)):
		eq = v1 == v2
	|(&(`Sym v1), &(`Sym v2)):
		eq = std.sleq(v1, v2)
	|_:
		eq = false
	;;
	
	if eq
		-> mksym(ctx, "#f")
	else
		-> mksym(ctx, "#t")
	;;
}

const addbuiltin = {ctx, name, f
	var b
	
	b = std.mk(`Builtin f)
	envdefine(ctx.global, mksym(ctx, name), b)
	addgcobj(ctx, b)
}

const addstdbuiltins = {ctx
	addbuiltin(ctx, "if", builtin_if)
	addbuiltin(ctx, "=", builtin_eq)
}

const main = {
	var ctx : lisp#
	var rdr : reader#
	
	ctx = mklisp()
	addstdbuiltins(ctx)
	if false
		rdr = mkreader(" (if )")
		for ; ;
			match read(ctx, rdr)
			| `std.Some v:
				eval(ctx, ctx.global, v)
				gc(ctx)
			| `std.None:
				break
			;;		
		;;
	;;
	
}
