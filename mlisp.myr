use std

type obj = union
	`Sym byte[:]
	`Int int64
	`List list
	`Func func
	`Env env#
;;

type list = struct
	head : obj#
	tail : obj#
;;

type func = struct
	body : list
;;

type env = struct
	parent : std.option(env#)
	map : std.htab(byte[:], obj#)#
;;

type ulisp = struct
	global : obj#
	gctab : std.htab(obj#, bool)#
	gcptrs : obj#[:]
;;

const newsym = {ctx, name
	 addgcobj(ctx, std.mk(`Sym std.sldup(name)))
}

const newenv = {ctx, parent : std.option(env#)
	var obj, env
	
	obj = std.alloc()
	env = std.alloc()
	env.map = std.mkht(std.strhash, std.streq)
	obj# = `Env env
	addgcobj(ctx, obj)
	-> obj
}

const addgcobj = {ctx, pobj
	ctx.gcptrs = std.slpush(ctx.gcptrs, pobj)
	std.htput(ctx.gctab, pobj, false)
}

const gchash = {pobj
	-> pobj castto(uint32)
}

const gceq = {a, b
	-> a == b
}

const gcfree = {obj
	match obj
	| &(`Sym name):
		std.slfree(name)
	| &(`Env env):
		std.htfree(env.map)
		std.free(env)
	| _:
		std.fatal("unimplemented gcfree\n")
	;;
	std.free(obj)
}

const walk = {gctab, pobj
	if std.get(std.htget(gctab, pobj))
		-> void
	;;
	std.htput(gctab, pobj, true)
	match pobj
	| &(`Sym _):
	| &(`Env e):
		var names = std.htkeys(e.map)
		for name in names
			walk(gctab, std.get(std.htget(e.map, name)))
		;;
		std.slfree(names)
	| _:
		std.fatal("unimplemented match")
	;;
}

const gc = {ctx
	var survivors, todie
	
	survivors = [][:]
	todie = [][:]
	
	for obj in ctx.gcptrs
		std.htput(ctx.gctab, obj, false) 
	;;
	
	walk(ctx.gctab, ctx.global)
	
	for obj in ctx.gcptrs
		var mark = std.get(std.htget(ctx.gctab, obj))
		if mark
			survivors = std.slpush(survivors, obj)
		else
			todie = std.slpush(todie, obj)
		;;
	;;
	std.slfree(ctx.gcptrs)
	ctx.gcptrs = survivors
	for obj in todie
		gcfree(obj)
	;;
	std.slfree(todie)
}

const newulisp = {
	var ctx
	
	ctx = std.alloc()
	ctx.gctab = std.mkht(gchash, gceq)
	ctx.gcptrs = std.slalloc(0)
	ctx.global = newenv(ctx, `std.None)
	-> ctx
}

const main = {
	var ctx : ulisp#
	
	ctx = newulisp()
	newsym(ctx, "foo")
	gc(ctx)
}
