use std

type obj = union
	`Sym byte[:]
	`Int int64
	`List list
	`Func func
	`Env env#
;;

type list = struct
	head : obj#
	tail : obj#
;;

type func = struct
	body : list
;;

type env = struct
	parent : std.option(env#)
	map : std.htab(byte[:], obj#)#
;;

type ulisp = struct
	global : env#
	gctab : std.htab(obj#, bool)#
	gcptrs : obj#[:]
;;

const newsym = {ctx, name
	 addgcobj(ctx, std.mk(`Sym std.sldup(name)))
}

const newenv = {ctx, parent : std.option(env#)
	var e
	
	e = std.mk([.map = std.mkht(std.strhash, std.streq)])
	addgcobj(ctx, std.mk(`Env e))
	-> e
}

const addgcobj = {ctx, pobj
	ctx.gcptrs = std.slpush(ctx.gcptrs, pobj)
	std.htput(ctx.gctab, pobj, false)
}

const gchash = {pobj
	-> pobj castto(uint32)
}

const gceq = {a, b
	-> a == b
}

const gcfree = {obj
	match obj
	| &`std.Sym name: std.free(name)
	| _: std.fatal("unimplemented gcfree")
	;;
	std.free(obj)
}

const gc = {ctx
	var survivors, todie
	
	survivors = [][:]
	todie = [][:]
	
	for obj in ctx.gcobjects
		std.htput(ctx.gctab, obj, false) 
	;;
	for obj in ctx.gcobjects
		match std.htget(ctx.gctab, obj)
		| `std.Some mark:
			if match
				survivors = std.slpush(survivors, obj)
			else
				todie = std.slpush(todie, obj)
			;;
		| `std.None:
			std.fatal("internal error\n")
		;;
	;;
	std.slfree(ctx.gcobjects)
	ctx.gcobjects = survivors
	for obj in todie
		gcfree(obj)
	;;
	std.slfree(todie)
}

const newulisp = {
	var ctx
	
	ctx = std.alloc()
	ctx.gctab = std.mkht(gchash, gceq)
	ctx.gcptrs = std.slalloc(0)
	ctx.global = newenv(ctx, `std.None)
	-> ctx
}

const main = {
	var ctx : ulisp#
	
	ctx = newulisp()
	newsym(ctx, "foo")
	gc(ctx)
}
