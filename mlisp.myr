use std

type obj = union
	`Sym byte[:]
	`Int int64
	`List std.option((obj#, obj#))
	`Func func
	`Builtin (ctx : ulisp#, e : env#, args : obj# -> obj#)
	`Env env#
;;

type reader = struct
	input : byte[:]
	idx : int
;;

type func = struct
	body : obj#
;;

type env = struct
	parent : std.option(obj#)
	child : std.option(obj#)
	map : std.htab(obj#, obj#)#
;;

type ulisp = struct
	global : obj#
	gcptrs : obj#[:]
;;

const envhash = {pobj
	match pobj
	| &(`Sym name):	-> std.strhash(name)
	| _:	std.fatal("internal error\n")
	;;
}

const enveq = {a, b
	match (a, b)
	| (&(`Sym n1), &(`Sym n2)):	-> std.streq(n1, n2)
	| _:	std.fatal("internal error\n")
	;;
}

const mkenv = {ctx, parent
	var obj, env
	
	obj = std.alloc()
	env = std.alloc()
	env.parent = parent
	env.child = `std.None
	env.map = std.mkht(envhash, enveq)
	obj# = `Env env
	addgcobj(ctx, obj)
	-> obj
}

const mkemptylist = {ctx
	var l
	
	l = std.mk(`List `std.None)
	addgcobj(ctx, l)
	-> l
}

const slicetolist = {ctx, sl
	var l
	
	l = mkemptylist(ctx)
	for var i = sl.len - 1; i > 0; i--
		l = mklist(ctx, sl[i], l)
	;;
	-> l
}

const mklist = {ctx, val, rest
	var l
	
	l = std.mk(`List `std.Some (val, rest))
	addgcobj(ctx, l)
	-> l
}

const mksym = {ctx, name
	var sym
	
	sym = std.mk(`Sym std.sldup(name))
	addgcobj(ctx, sym)
	-> sym	
}

const mknum = {ctx, v
	var n
	
	n = std.mk(`Int v)
	addgcobj(ctx, n)
	-> n	
}

const addgcobj = {ctx, pobj
	ctx.gcptrs = std.slpush(ctx.gcptrs, pobj)
}

const gchash = {pobj
	-> pobj castto(uint32)
}

const gceq = {a, b
	-> a == b
}

const gcfree = {pobj
	match pobj
	| &(`Sym name):
		std.put("a")
		std.slfree(name)
	| &(`Env env):
		std.htfree(env.map)
		std.free(env)
	| &(`List _):
	| &(`Int _):
	| &(`Func _):
	| &(`Builtin _):
	;;
	std.free(pobj)
}

const gcwalk = {gctab, pobj
	if std.get(std.htget(gctab, pobj))
		-> void
	;;
	std.htput(gctab, pobj, true)
	match pobj
	| &(`Sym _):
	| &(`Int _):
	| &(`Env e):
		var syms = std.htkeys(e.map)
		for sym in syms
			gcwalk(gctab, sym)
			gcwalk(gctab, std.get(std.htget(e.map, sym)))
		;;
		std.slfree(syms)
	| &(`List `std.Some (val, rest)):
		gcwalk(gctab, val)
		gcwalk(gctab, rest)
	| &(`List `std.None):
	| &(`Func f):
		gcwalk(gctab, f.body)
	| &(`Builtin _):
	;;
}

const gc = {ctx
	var survivors, todie
	var marktab, marked
	
	survivors = [][:]
	todie = [][:]
	
	marktab = std.mkht(gchash, gceq)
	for obj in ctx.gcptrs
		std.htput(marktab, obj, false) 
	;;
	/* mark */
	gcwalk(marktab, ctx.global)
	/* sweep */
	for obj in ctx.gcptrs
		marked = std.get(std.htget(marktab, obj))
		if marked
			survivors = std.slpush(survivors, obj)
		else
			todie = std.slpush(todie, obj)
		;;
	;;
	for obj in todie
		gcfree(obj)
	;;
	std.htfree(marktab)
	std.slfree(ctx.gcptrs)
	std.slfree(todie)
	ctx.gcptrs = survivors
}

const envdefine = {env, sym, pobj
	match env
	| &(`Env e):	std.htput(e.map, sym, pobj)
	| _:	std.fatal("internal error\n")
	;;
	-> pobj
}

const envlookup = {env, sym
	match env
	| &(`Env e):
		match std.htget(e.map, sym)
		| `std.Some v:	-> `std.Some v
		| `std.None:
		;;
		match e.parent
		| `std.Some p:	-> envlookup(p, sym)
		| `std.None:	-> `std.None
		;;
	| _:
		std.fatal("internal error\n")
	;;
}

const eval = {ctx, env, val
	match val
	| &(`Sym name):
		match envlookup(env, val)
		| `std.Some r: -> r
		| `std.None:	std.fatal("cannot find {} in the current scope\n", name)
		;;
	| &(`Int _): -> val
	| &(`List _): -> evallist(ctx, env, val)
	| _: std.fatal("cannot eval value\n")
	;;
}

const apply = {ctx, env, f, params
	-> mksym(ctx, "fuck")
}

const evallist = {ctx, env, list
	var f, params, listparams
	
	match list
	| &(`List `std.None):
		std.fatal("cannot eval an empty list")
	| &(`List `std.Some (val, rest)):
		f = eval(ctx, env, val)
		match f
		| &(`Builtin _): std.fatal("builtins not implemented\n")
		| &(`Func _):
			params = std.slalloc(0)
			while true
				match rest
				| &(`List `std.Some(v, tail)):
					rest = tail
					params = std.slpush(params, eval(ctx, env, v))
				| &(`List `std.None):
				| _:
					std.fatal("list tail is not a list\n")
				;;
			;;
			listparams = slicetolist(ctx, params)
			std.slfree(params)
			-> apply(ctx, env, f, listparams)
		| _: std.fatal("can only call builtins or functions")
		;;
	| _: std.fatal("internal error\n")
	;;
}

const newulisp = {
	var ctx
	
	ctx = std.alloc()
	ctx.gcptrs = [][:]
	ctx.global = mkenv(ctx, `std.None)
	-> ctx
}

const mkrdr = {txt -> reader#
	-> std.mk([.input = txt, .idx = 0])
}

const peekchar = {rdr
	if rdr.idx == rdr.input.len
		-> `std.None
	;;
	-> `std.Some rdr.input[rdr.idx]
}

const getchar = {rdr
	var c
	
	c = peekchar(rdr)
	rdr.idx++
	-> c
}

const isdigit = {c
	if c < '0' castto(byte)
		-> false
	;;
	if c > '9' castto(byte)
		-> false
	;;
	-> true
}

const isws = {b
	var c
	
	c = b castto(char)
	if c == ' ' || c == '\n' || c == '\t'
		-> true
	;;
	-> false
}

const readnum = {ctx, rdr
	var n
	
	n = 0
	while true
		match peekchar(rdr)
		| `std.Some c:
			if !isdigit(c)
				break
			;;
			getchar(rdr)
			n *= 10
			n += (c - ('0' castto(byte))) castto(int64)
		| `std.None:
			break
		;;
	;;
	-> mknum(ctx, n)
}

const readsym = {ctx, rdr
	var name, sym
	
	name = [][:]
	while true
		match peekchar(rdr)
		| `std.Some c:
			if c == 40 || c == 41 || isws(c)
				break
			;;
			name = std.slpush(name, c)
			getchar(rdr)	
		| `std.None:
			break
		;;
	;;
	sym = mksym(ctx, name)
	std.slfree(name)
	-> sym
}

const readlist = {ctx, rdr
	var l, sl
	
	sl = std.slalloc(0)
	getchar(rdr)
	while true
		match peekchar(rdr)
		| `std.Some 41:
			getchar(rdr)
			break
		| `std.None:
			std.fatal("unclosed list\n")
		| _:
			match read(ctx, rdr)
			| `std.Some v:
				sl = std.slpush(sl, v)
			| _:
				std.fatal("failed to read list element\n")
			;;
		;;
	;;
	l = slicetolist(ctx, sl)
	std.slfree(sl)
	-> l
}

const read = {ctx : ulisp#, rdr : reader# -> std.option(obj#) 
	match peekchar(rdr)
	| `std.Some 40:
		-> `std.Some readlist(ctx, rdr)
	| `std.Some c:
		if isdigit(c)
			-> `std.Some readnum(ctx, rdr)
		;;
		if isws(c)
			getchar(rdr)
			-> read(ctx, rdr)
		;;
		-> `std.Some readsym(ctx, rdr)
	| `std.None:
		-> `std.None
	;;
}

const main = {
	var ctx : ulisp#
	var rdr : reader#
	var v
	
	ctx = newulisp()
	for ; ;
		v = mknum(ctx, 3)
		gc(ctx)		
	;;
	
}
