use std

type obj = union
	`Sym byte[:]
	`Int int64
	`List list
	`Func func
	`Env env#
;;

type list = struct
	head : obj#
	tail : obj#
;;

type func = struct
	body : obj#
;;

type env = struct
	parent : std.option(env#)
	map : std.htab(obj#, obj#)#
;;

type ulisp = struct
	global : obj#
	gctab : std.htab(obj#, bool)#
	gcptrs : obj#[:]
;;


const envhash = {pobj
	match pobj
	| &(`Sym name):	-> std.strhash(name)
	| _:	std.fatal("internal error\n")
	;;
}

const enveq = {a, b
	match (a, b)
	| (&(`Sym n1), &(`Sym n2)):	-> std.streq(n1, n2)
	| _:	std.fatal("internal error\n")
	;;
}

const newenv = {ctx, parent : std.option(env#)
	var obj, env
	
	obj = std.alloc()
	env = std.alloc()
	env.map = std.mkht(envhash, enveq)
	obj# = `Env env
	addgcobj(ctx, obj)
	-> obj
}

const newsym = {ctx, name
	var sym
	
	sym = std.mk(`Sym std.sldup(name))
	addgcobj(ctx, sym)
	-> sym	
}

const addgcobj = {ctx, pobj
	ctx.gcptrs = std.slpush(ctx.gcptrs, pobj)
	std.htput(ctx.gctab, pobj, false)
}

const gchash = {pobj
	-> pobj castto(uint32)
}

const gceq = {a, b
	-> a == b
}

const gcfree = {obj
	match obj
	| &(`Sym name):
		std.slfree(name)
	| &(`Env env):
		std.htfree(env.map)
		std.free(env)
	| &(`Int _):
	| &(`List _):
	| &(`Func _):
	;;
	std.free(obj)
}

const gcwalk = {gctab, pobj
	if std.get(std.htget(gctab, pobj))
		-> void
	;;
	std.htput(gctab, pobj, true)
	match pobj
	| &(`Sym _):
	| &(`Int _):
	| &(`Env e):
		var syms = std.htkeys(e.map)
		for sym in syms
			gcwalk(gctab, sym)
			gcwalk(gctab, std.get(std.htget(e.map, sym)))
		;;
		std.slfree(syms)
	| &(`List l):
		gcwalk(gctab, l.head)
		gcwalk(gctab, l.tail)
	| &(`Func f):
		gcwalk(gctab, f.body)
	;;
}

const gc = {ctx
	var survivors, todie
	
	survivors = [][:]
	todie = [][:]
	
	for obj in ctx.gcptrs
		std.htput(ctx.gctab, obj, false) 
	;;
	
	gcwalk(ctx.gctab, ctx.global)
	
	for obj in ctx.gcptrs
		var mark = std.get(std.htget(ctx.gctab, obj))
		if mark
			survivors = std.slpush(survivors, obj)
		else
			todie = std.slpush(todie, obj)
		;;
	;;
	ctx.gcptrs = survivors
	for obj in todie
		gcfree(obj)
	;;
	std.slfree(ctx.gcptrs)
	std.slfree(todie)
}

const envdefine = {env, sym, pobj
	match env
	| &(`Env e):	std.htput(e.map, sym, pobj)
	| _:	std.fatal("internal error\n")
	;;
}

const newulisp = {
	var ctx
	
	ctx = std.alloc()
	ctx.gctab = std.mkht(gchash, gceq)
	ctx.gcptrs = [][:]
	ctx.global = newenv(ctx, `std.None)
	-> ctx
}

const main = {
	var ctx : ulisp#
	
	ctx = newulisp()
	while true
		newsym(ctx, "foo")
		envdefine(ctx.global, newsym(ctx, "x"), newsym(ctx, "bar"))
		newenv(ctx, `std.None)
		gc(ctx)
	;;
}
